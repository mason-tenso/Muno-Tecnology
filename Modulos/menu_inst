#!/bin/bash
[[ $1 != "" ]] && id="$1" || id="es"
cor[0]="\033[1;37m"
cor[1]="\033[1;34m"
cor[2]="\033[1;31m"
cor[3]="\033[1;33m"
cor[4]="\033[1;32m'"
barra="\033[1;34m=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=#=\033[1;37m"

#LISTA PORTAS
mportas () {
unset portas
portas_var=$(lsof -V -i tcp -P -n | grep -v "ESTABLISHED" |grep -v "COMMAND" | grep "LISTEN")
while read port; do
var1=$(echo $port | awk '{print $1}') && var2=$(echo $port | awk '{print $9}' | awk -F ":" '{print $2}')
[[ "$(echo -e $portas|grep "$var1 $var2")" ]] || portas+="$var1 $var2\n"
done <<< "$portas_var"
i=1
echo -e "$portas"
}

#MEU IP
fun_ip () {
MEU_IP=$(ip addr | grep 'inet' | grep -v inet6 | grep -vE '127\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}' | grep -o -E '[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}' | head -1)
MEU_IP2=$(wget -qO- ipv4.icanhazip.com)
[[ "$MEU_IP" != "$MEU_IP2" ]] && IP="$MEU_IP2" || IP="$MEU_IP"
}

#ETHOOL SSH
fun_eth () {
eth=$(ifconfig | grep -v inet6 | grep -v lo | grep -v 127.0.0.1 | grep "encap:Ethernet" | awk '{print $1}')
    [[ $eth != "" ]] && {
    echo -e "$barra"
    echo -e "${cor[3]} $(source trans -b pt:${id} "Aplicar Sistema Para Melhorar Pacotes Ssh?")"
    echo -e "${cor[3]} $(source trans -b pt:${id} "Opcao Para Usuarios Avancados")"
    echo -e "$barra"
    read -p " [S/N]: " -e -i n sshsn
           [[ "$sshsn" = @(s|S|y|Y) ]] && {
           echo -e "${cor[1]} $(source trans -b pt:${id} "Correcao de problemas de pacotes no SSH...")"
           echo -e " $(source trans -b pt:${id} "Qual A Taxa RX")"
           echo -ne "[ 1 - 999999999 ]: "; read rx
           [[ "$rx" = "" ]] && rx="999999999"
           echo -e " $(source trans -b pt:${id} "Qual A Taxa TX")"
           echo -ne "[ 1 - 999999999 ]: "; read tx
           [[ "$tx" = "" ]] && tx="999999999"
           apt-get install ethtool -y > /dev/null 2>&1
           ethtool -G $eth rx $rx tx $tx > /dev/null 2>&1
           }
     echo -e "$barra"
     }
}

#FUN_BAR
fun_bar () {
comando="$1"
 _=$(
$comando > /dev/null 2>&1
) & > /dev/null
pid=$!
while [[ -d /proc/$pid ]]; do
echo -ne " \033[1;33m["
   for((i=0; i<10; i++)); do
   echo -ne "\033[1;31m##"
   sleep 0.2
   done
echo -ne "\033[1;33m]"
sleep 1s
echo
tput cuu1
tput dl1
done
echo -e " \033[1;33m[\033[1;31m####################\033[1;33m] - \033[1;32m100%\033[0m"
sleep 1s
}

#INSTALADOR SQUID
fun_squid  () {
  if [[ -e /etc/squid/squid.conf ]]; then
  var_squid="/etc/squid/squid.conf"
  elif [[ -e /etc/squid3/squid.conf ]]; then
  var_squid="/etc/squid3/squid.conf"
  fi
  [[ -e $var_squid ]] && {
  echo -e "$barra\n\033[1;32m $(source trans -b pt:${id} "REMOVENDO SQUID")\n$barra"
  fun_bar "apt-get remove squid3 -y"
  service squid stop > /dev/null 2>&1
  echo -e "$barra\n\033[1;32m $(source trans -b pt:${id} "Procedimento Concluido")\n$barra"
  [[ -e $var_squid ]] && rm $var_squid
  return 0
  }
echo -e "$barra\n\033[1;32m $(source trans -b pt:${id} "INSTALADOR SQUID ADM-ULTIMATE")\n$barra"
fun_ip
echo -ne " $(source trans -b pt:${id} "Confirme seu ip")"; read -p ": " -e -i $IP ip
echo -e " $(source trans -b pt:${id} "Agora Escolha as Portas que Deseja No Squid")"
echo -e " $(source trans -b pt:${id} "Escolha As Portas Em Ordem Sequencial Exemplo: 80 8080 8799 3128")"
echo -ne " $(source trans -b pt:${id} "Digite as Portas:") "; read portasx
totalporta=($portasx)
unset PORT
   for((i=0; i<${#totalporta[@]}; i++)); do
        [[ $(mportas|grep "${totalporta[$i]}") = "" ]] && {
        echo -e "\033[1;33m $(source trans -b pt:${id} "Porta Escolhida:")\033[1;32m ${totalporta[$i]} OK"
        PORT+="${totalporta[$i]}\n"
        } || {
        echo -e "\033[1;33m $(source trans -b pt:${id} "Porta Escolhida:")\033[1;31m ${totalporta[$i]} FAIL"
        }
   done
  [[ "$(echo -e $PORT)" = "" ]] && {
  echo -e "\033[1;31m $(source trans -b pt:${id} "Nenhuma Porta Valida Foi Escolhida")\033[0m"
  return 1
  }
echo -e "$barra"
echo -e " $(source trans -b pt:${id} "INSTALANDO SQUID")"
echo -e "$barra"
fun_bar "apt-get install squid3 -y"
echo -e "$barra"
echo -e " $(source trans -b pt:${id} "INICIANDO CONFIGURACAO")"
echo -e ".bookclaro.com.br/\n.claro.com.ar/\n.claro.com.br/\n.claro.com.co/\n.claro.com.ec/\n.claro.com.gt/\n.claro.com.ni/\n.claro.com.pe/\n.claro.com.sv/\n.claro.cr/\n.clarocurtas.com.br/\n.claroideas.com/\n.claroideias.com.br/\n.claromusica.com/\n.clarosomdechamada.com.br/\n.clarovideo.com/\n.facebook.net/\n.facebook.com/\n.netclaro.com.br/\n.oi.com.br/\n.oimusica.com.br/\n.speedtest.net/\n.tim.com.br/\n.timanamaria.com.br/\n.vivo.com.br/\n.rdio.com/\n.compute-1.amazonaws.com/\n.portalrecarga.vivo.com.br/\n.vivo.ddivulga.com/" > /etc/payloads
echo -e "$barra\n\033[1;32m $(source trans -b pt:${id} "Agora Escolha Uma Conf Para Seu Proxy")\n$barra"
echo -e "|1| $(source trans -b pt:${id} "Comum")"
echo -e "|2| $(source trans -b pt:${id} "Customizado") -\033[1;31m $(source trans -b pt:${id} "Usuario Deve Ajustar")\033[1;37m\n$barra"
read -p "[1/2]: " -e -i 1 proxy_opt
unset var_squid
if [[ -d /etc/squid ]]; then
var_squid="/etc/squid/squid.conf"
elif [[ -d /etc/squid3 ]]; then
var_squid="/etc/squid3/squid.conf"
fi
if [[ "$proxy_opt" = @(02|2) ]]; then
echo -e "#ConfiguracaoSquiD
acl url1 dstdomain -i $ip
acl url2 dstdomain -i 127.0.0.1
acl url3 url_regex -i '/etc/payloads'
acl url4 dstdomain -i localhost
acl accept dstdomain -i GET
acl accept dstdomain -i POST
acl accept dstdomain -i OPTIONS
acl accept dstdomain -i CONNECT
acl accept dstdomain -i PUT
acl HEAD dstdomain -i HEAD
acl accept dstdomain -i TRACE
acl accept dstdomain -i OPTIONS
acl accept dstdomain -i PATCH
acl accept dstdomain -i PROPATCH
acl accept dstdomain -i DELETE
acl accept dstdomain -i REQUEST
acl accept dstdomain -i METHOD
acl accept dstdomain -i NETDATA
acl accept dstdomain -i MOVE
acl all src 0.0.0.0/0
http_access allow url1
http_access allow url2
http_access allow url3
http_access allow url4
http_access allow accept
http_access allow HEAD
http_access allow all

# Request Headers Forcing

request_header_access Allow allow all
request_header_access Authorization allow all
request_header_access WWW-Authenticate allow all
request_header_access Proxy-Authorization allow all
request_header_access Proxy-Authenticate allow all
request_header_access Cache-Control allow all
request_header_access Content-Encoding allow all
request_header_access Content-Length allow all
request_header_access Content-Type allow all
request_header_access Date allow all
request_header_access Expires allow all
request_header_access Host allow all
request_header_access If-Modified-Since allow all
request_header_access Last-Modified allow all
request_header_access Location allow all
request_header_access Pragma allow all
request_header_access Accept allow all
request_header_access Accept-Charset allow all
request_header_access Accept-Encoding allow all
request_header_access Accept-Language allow all
request_header_access Content-Language allow all
request_header_access Mime-Version allow all
request_header_access Retry-After allow all
request_header_access Title allow all
request_header_access Connection allow all
request_header_access Proxy-Connection allow all
request_header_access User-Agent allow all
request_header_access Cookie allow all
request_header_access All deny all

# Response Headers Spoofing

reply_header_access Via deny all
reply_header_access X-Cache deny all
reply_header_access X-Cache-Lookup deny all


#portas" > $var_squid
for pts in $(echo -e $PORT); do
echo -e "http_port $pts" >> $var_squid
done
echo -e "
#nome
visible_hostname ADM-MANAGER

via off
forwarded_for off
pipeline_prefetch off" >> $var_squid
 else
echo -e "#ConfiguracaoSquiD
acl url1 dstdomain -i $ip
acl url2 dstdomain -i 127.0.0.1
acl url3 url_regex -i '/etc/payloads'
acl url4 dstdomain -i localhost
acl all src 0.0.0.0/0
http_access allow url1
http_access allow url2
http_access allow url3
http_access allow url4
http_access allow all

#portas" > $var_squid
for pts in $(echo -e $PORT); do
echo -e "http_port $pts" >> $var_squid
done
echo -e "
#nome
visible_hostname ADM-MANAGER

via off
forwarded_for off
pipeline_prefetch off" >> $var_squid
fi
fun_eth
echo -e " \033[1;31m [ ! ] \033[1;33m$(source trans -b pt:${id} "REINICIANDO SERVICOS")"
squid3 -k reconfigure > /dev/null 2>&1
service ssh restart > /dev/null 2>&1
service squid3 restart > /dev/null 2>&1
echo -ne " \033[1;32m[OK]"
echo -e "$barra\n ${cor[3]}$(source trans -b pt:${id} "SQUID CONFIGURADO")\n$barra"
mportas > /tmp/portz
while read portas; do
[[ $portas = "" ]] && break
echo -e " $(source trans -b pt:${id} "SERVICO"): $(echo $portas|awk '{print $1}') $(source trans -b pt:${id} "PORTA"): $(echo $portas|awk '{print $2}')"
done < /tmp/portz
echo -e "$barra"
#UFW
for ufww in $(mportas|awk '{print $2}'); do
ufw allow $ufww > /dev/null 2>&1
done
rm /tmp/portz
}

fun_dropbear () {
 [[ -e /etc/default/dropbear ]] && {
 echo -e "$barra\n\033[1;32m $(source trans -b pt:${id} "REMOVENDO DROPBEAR")\n$barra"
 fun_bar "apt-get remove dropbear -y"
 echo -e "$barra\n\033[1;32m $(source trans -b pt:${id} "Dropbear Removido")\n$barra"
 [[ -e /etc/default/dropbear ]] && rm /etc/default/dropbear
 return 0
 }
echo -e "$barra\n\033[1;32m $(source trans -b pt:${id} "INSTALADOR DROPBEAR ADM-ULTIMATE")\n$barra"
echo -e " $(source trans -b pt:${id} "POR PADRAO, DROPBEAR USA A PORTA 443")\033[1;37m"
echo -e "$barra"
   [[ $(mportas|grep 443) != "" ]] && {
   echo -e "033[1;31m $(source trans -b pt:${id} "PORTA 443 EM USO")\033[1;37m"
   echo -e "033[1;31m $(source trans -b pt:${id} "LIBERE ELA, E TENTE NOVAMENTE")\033[1;37m"
   echo -e "$barra"
   return 1
   }
sysvar=$(cat -n /etc/issue |grep 1 |cut -d' ' -f6,7,8 |sed 's/1//' |sed 's/      //' | grep -o Ubuntu)
shells=$(cat /etc/shells|grep "/bin/false")
[[ ! ${shells} ]] && echo -e "/bin/false" >> /etc/shells
[[ "$sysvar" != "" ]] && {
echo -e "Port 22
Protocol 2
KeyRegenerationInterval 3600
ServerKeyBits 1024
SyslogFacility AUTH
LogLevel INFO
LoginGraceTime 120
PermitRootLogin yes
StrictModes yes
RSAAuthentication yes
PubkeyAuthentication yes
IgnoreRhosts yes
RhostsRSAAuthentication no
HostbasedAuthentication no
PermitEmptyPasswords no
ChallengeResponseAuthentication no
PasswordAuthentication yes
X11Forwarding yes
X11DisplayOffset 10
PrintMotd no
PrintLastLog yes
TCPKeepAlive yes
#UseLogin no
AcceptEnv LANG LC_*
Subsystem sftp /usr/lib/openssh/sftp-server
UsePAM yes" > /etc/ssh/sshd_config
echo -e "${cor[2]} $(source trans -b pt:${id} "Instalando dropbear")"
echo -e "$barra"
fun_bar "apt-get install dropbear -y"
echo -e "$barra"
touch /etc/dropbear/banner
echo -e "${cor[2]} $(source trans -b pt:${id} "Configurando dropbear")"
echo -e "NO_START=0" > /etc/default/dropbear
echo -e 'DROPBEAR_EXTRA_ARGS="-p 443"' >> /etc/default/dropbear
echo -e 'DROPBEAR_BANNER="/etc/dropbear/banner"' >> /etc/default/dropbear
echo -e "DROPBEAR_RECEIVE_WINDOW=65536" >> /etc/default/dropbear
} || {
echo -e "Port 22
Protocol 2
KeyRegenerationInterval 3600
ServerKeyBits 1024
SyslogFacility AUTH
LogLevel INFO
LoginGraceTime 120
PermitRootLogin yes
StrictModes yes
RSAAuthentication yes
PubkeyAuthentication yes
IgnoreRhosts yes
RhostsRSAAuthentication no
HostbasedAuthentication no
PermitEmptyPasswords no
ChallengeResponseAuthentication no
PasswordAuthentication yes
X11Forwarding yes
X11DisplayOffset 10
PrintMotd no
PrintLastLog yes
TCPKeepAlive yes
#UseLogin no
AcceptEnv LANG LC_*
Subsystem sftp /usr/lib/openssh/sftp-server
UsePAM yes" > /etc/ssh/sshd_config
echo -e "${cor[2]} $(source trans -b pt:${id} "Instalando dropbear")"
echo -e "$barra"
fun_bar "apt-get install dropbear -y"
touch /etc/dropbear/banner
echo -e "$barra"
echo -e "${cor[2]} $(source trans -b pt:${id} "Configurando dropbear")"
echo -e "NO_START=0" > /etc/default/dropbear
echo -e 'DROPBEAR_EXTRA_ARGS="-p 443"' >> /etc/default/dropbear
echo -e 'DROPBEAR_BANNER="/etc/dropbear/banner"' >> /etc/default/dropbear
echo -e "DROPBEAR_RECEIVE_WINDOW=65536" >> /etc/default/dropbear
}
fun_eth
service ssh restart > /dev/null 2>&1
service dropbear restart > /dev/null 2>&1
echo -e "$barra\n${cor[3]} $(source trans -b pt:${id} "Seu dropbear foi configurado com sucesso")\n$barra"
mportas > /tmp/portz
while read portas; do
[[ $portas = "" ]] && break
echo -e "\033[1;33m$(source trans -b pt:${id} "SERVICO"): \033[1;32m$(echo $portas|awk '{print $1}') \033[1;33m$(source trans -b pt:${id} "PORTA"): \033[1;32m$(echo $portas|awk '{print $2}')"
done < /tmp/portz
echo -e "$barra"
#UFW
for ufww in $(mportas|awk '{print $2}'); do
ufw allow $ufww > /dev/null 2>&1
done
rm /tmp/portz
}


instala_ovpn () {
if readlink /proc/$$/exe | grep -q "dash"; then
	exit
fi

if [[ "$EUID" -ne 0 ]]; then
	exit
fi

if [[ ! -e /dev/net/tun ]]; then
	exit
fi

if [[ -e /etc/debian_version ]]; then
	OS=debian
	GROUPNAME=nogroup
	RCLOCAL='/etc/rc.local'
elif [[ -e /etc/centos-release || -e /etc/redhat-release ]]; then
	OS=centos
	GROUPNAME=nobody
	RCLOCAL='/etc/rc.d/rc.local'
else
	exit
fi

	#Instal
	echo -e " $(source trans -b pt:${id} "Responda as perguntas para iniciar a instalacao")"
	echo -e " $(source trans -b pt:${id} "Responda corretamente")"
	echo -e " \033[1;33m$(source trans -b pt:${id} "Primeiro precisamos do ip de sua maquina, este ip esta correto?")\033[0m"
	# Autodetect IP address and pre-fill for the user
	IP=$(ip addr | grep 'inet' | grep -v inet6 | grep -vE '127\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}' | grep -oE '[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}' | head -1)
	read -p " IP address: " -e -i $IP IP
	# If $IP is a private IP address, the server must be behind NAT
	if echo "$IP" | grep -qE '^(10\.|172\.1[6789]\.|172\.2[0-9]\.|172\.3[01]\.|192\.168)'; then
		echo
		echo " \033[1;33m$(source trans -b en:${id} This server is behind NAT. What is the public IPv4 address or hostname?)"
		read -p " Public IP address / hostname: " -e PUBLICIP
	fi
	echo -e " \033[1;31m$(source trans -b pt:${id} "Qual protocolo voce deseja para as conexoes OPENVPN?")"
	echo -e " \033[1;31m$(source trans -b pt:${id} "A menos que o UDP esteja bloqueado, você não deve usar o TCP (mais lento)")"
	#PROTOCOLO
	echo "   1) UDP (Recomendado)"
	echo "   2) TCP"
	read -p " Protocolo [1-2]: " -e -i 1 PROTOCOL
	case $PROTOCOL in
		1) 
		PROTOCOL=udp
		;;
		2) 
		PROTOCOL=tcp
		;;
	esac
	echo -e "$barra\n \033[1;33m$(source trans -b pt:${id} "Qual porta voce deseja usar?")\033[0m\n$barra"
	read -p " Port: " -e -i 1194 PORT
	#DNS
	echo -e "$barra\n \033[1;33m$(source trans -b pt:${id} "Qual DNS voce deseja usar?")\n$barra"
	echo "   1) Usar DNS del sistema"
	echo "   2) Cloudflare (Anycast: worldwide)"
	echo "   3) Quad9 (Anycast: worldwide)"
	echo "   4) FDN (France)"
	echo "   5) DNS.WATCH (Germany)"
	echo "   6) OpenDNS (Anycast: worldwide)"
	echo "   7) Google (Anycast: worldwide)"
	echo "   8) Yandex Basic (Russia)"
	echo "   9) AdGuard DNS (Russia)"
	read -p " DNS [1-9]: " -e -i 1 DNS
	#CIPHER
	echo -e "$barra\n \033[1;33m$(source trans -b es:${id} "Escoja el tipo de codificación que desea usar para el canal de datos:")\n$barra"
	echo "   1) AES-128-CBC"
	echo "   2) AES-192-CBC"
	echo "   3) AES-256-CBC"
	echo "   4) CAMELLIA-128-CBC"
	echo "   5) CAMELLIA-192-CBC"
	echo "   6) CAMELLIA-256-CBC"
	echo "   7) SEED-CBC"
	while [[ $CIPHER != @(1|2|3|4|5|6|7) ]]; do
	read -p " Cipher [1-7]: " -e -i 1 CIPHER
	done
	case $CIPHER in
	1) CIPHER="cipher AES-128-CBC";;
	2) CIPHER="cipher AES-192-CBC";;
	3) CIPHER="cipher AES-256-CBC";;
	4) CIPHER="cipher CAMELLIA-128-CBC";;
	5) CIPHER="cipher CAMELLIA-192-CBC";;
	6) CIPHER="cipher CAMELLIA-256-CBC";;
	7) CIPHER="cipher SEED-CBC";;
	esac
	CLIENT="ADMULTIMATE"
	echo -e "$barra\n \033[1;33m$(source trans -b pt:${id} "Estamos prontos para configurar seu servidor OpenVPN")\n$barra"
	read -n1 -r -p " Enter to Continue..."
	echo -e "$barra"
	if [[ "$OS" = 'debian' ]]; then
	echo -ne " \033[1;31m[ ! ] apt-get update"
		apt-get update > /dev/null 2>&1
		apt-get install openvpn iptables openssl ca-certificates -y > /dev/null 2>&1 && echo -e "\033[1;32m [OK]"
	else
		# Else, the distro is CentOS
	echo -ne " \033[1;31m[ ! ] apt-get update"
		yum install epel-release -y > /dev/null 2>&1
		yum install openvpn iptables openssl ca-certificates -y > /dev/null 2>&1 && echo -e "\033[1;32m [OK]"
	fi
	# Get easy-rsa
	echo -ne " \033[1;31m[ ! ] apt-get install openvpn curl openssl"
	wget -O ~/EasyRSA-3.0.4.tgz "https://github.com/OpenVPN/easy-rsa/releases/download/v3.0.4/EasyRSA-3.0.4.tgz" > /dev/null 2>&1 && echo -e "\033[1;32m [OK]"
	tar xzf ~/EasyRSA-3.0.4.tgz -C ~/
	[[ ! -d /etc/openvpn/ ]] && mkdir /etc/openvpn/
	mv ~/EasyRSA-3.0.4/ /etc/openvpn/
	mv /etc/openvpn/EasyRSA-3.0.4/ /etc/openvpn/easy-rsa/
	chown -R root:root /etc/openvpn/easy-rsa/
	rm -rf ~/EasyRSA-3.0.4.tgz
	cd /etc/openvpn/easy-rsa/
	# Create the PKI, set up the CA, the DH params and the server + client certificates
	echo -ne " \033[1;31m[ ! ] Generating CA Config"
	./easyrsa init-pki > /dev/null 2>&1
	./easyrsa --batch build-ca nopass > /dev/null 2>&1
	./easyrsa gen-dh > /dev/null 2>&1
	./easyrsa build-server-full server nopass > /dev/null 2>&1
	./easyrsa build-client-full $CLIENT nopass > /dev/null 2>&1
	EASYRSA_CRL_DAYS=3650 ./easyrsa gen-crl > /dev/null 2>&1
	# Move the stuff we need
	cp pki/ca.crt pki/private/ca.key pki/dh.pem pki/issued/server.crt pki/private/server.key pki/crl.pem /etc/openvpn
	# CRL is read with each client connection, when OpenVPN is dropped to nobody
	chown nobody:$GROUPNAME /etc/openvpn/crl.pem
	# Generate key for tls-auth
	openvpn --genkey --secret /etc/openvpn/ta.key > /dev/null 2>&1
	# Generate server.conf
	echo -e "\033[1;32m [OK]"
	echo -ne " \033[1;31m[ ! ] Generating Server Config"
	echo "port $PORT
proto $PROTOCOL
dev tun
sndbuf 0
rcvbuf 0
ca ca.crt
cert server.crt
key server.key
dh dh.pem
auth SHA512
tls-auth ta.key 0
topology subnet
server 10.8.0.0 255.255.255.0
ifconfig-pool-persist ipp.txt" > /etc/openvpn/server.conf
	echo 'push "redirect-gateway def1 bypass-dhcp"' >> /etc/openvpn/server.conf
	# DNS
	case $DNS in
		1)
		# Locate the proper resolv.conf
		# Needed for systems running systemd-resolved
		if grep -q "127.0.0.53" "/etc/resolv.conf"; then
			RESOLVCONF='/run/systemd/resolve/resolv.conf'
		else
			RESOLVCONF='/etc/resolv.conf'
		fi
		# Obtain the resolvers from resolv.conf and use them for OpenVPN
		grep -v '#' $RESOLVCONF | grep 'nameserver' | grep -E -o '[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}' | while read line; do
			echo "push \"dhcp-option DNS $line\"" >> /etc/openvpn/server.conf
		done
		;;
		2) # Cloudflare
		echo 'push "dhcp-option DNS 1.0.0.1"' >> /etc/openvpn/server.conf
		echo 'push "dhcp-option DNS 1.1.1.1"' >> /etc/openvpn/server.conf	
		;;
		3) # Quad9
		echo 'push "dhcp-option DNS 9.9.9.9"' >> /etc/openvpn/server.conf
		;;
		4) # FDN
		echo 'push "dhcp-option DNS 80.67.169.40"' >> /etc/openvpn/server.conf
		echo 'push "dhcp-option DNS 80.67.169.12"' >> /etc/openvpn/server.conf
		;;
		5) # DNS.WATCH
		echo 'push "dhcp-option DNS 84.200.69.80"' >> /etc/openvpn/server.conf
		echo 'push "dhcp-option DNS 84.200.70.40"' >> /etc/openvpn/server.conf
		;;
		6) # OpenDNS
		echo 'push "dhcp-option DNS 208.67.222.222"' >> /etc/openvpn/server.conf
		echo 'push "dhcp-option DNS 208.67.220.220"' >> /etc/openvpn/server.conf
		;;
		7) # Google
		echo 'push "dhcp-option DNS 8.8.8.8"' >> /etc/openvpn/server.conf
		echo 'push "dhcp-option DNS 8.8.4.4"' >> /etc/openvpn/server.conf
		;;
		8) # Yandex Basic
		echo 'push "dhcp-option DNS 77.88.8.8"' >> /etc/openvpn/server.conf
		echo 'push "dhcp-option DNS 77.88.8.1"' >> /etc/openvpn/server.conf
		;;
		9) # AdGuard DNS
		echo 'push "dhcp-option DNS 176.103.130.130"' >> /etc/openvpn/server.conf
		echo 'push "dhcp-option DNS 176.103.130.131"' >> /etc/openvpn/server.conf
		;;
	esac
	echo "keepalive 10 120
$CIPHER
comp-lzo
user nobody
group $GROUPNAME
persist-key
persist-tun
status openvpn-status.log
verb 3
crl-verify crl.pem" >> /etc/openvpn/server.conf
echo -e "\033[1;32m [OK]"
	# Enable net.ipv4.ip_forward for the system
	
	echo 'net.ipv4.ip_forward=1' > /etc/sysctl.d/30-openvpn-forward.conf
	# Enable without waiting for a reboot or service restart
	echo 1 > /proc/sys/net/ipv4/ip_forward
	if pgrep firewalld; then
		# Using both permanent and not permanent rules to avoid a firewalld
		# reload.
		# We don't use --add-service=openvpn because that would only work with
		# the default port and protocol.
		firewall-cmd --zone=public --add-port=$PORT/$PROTOCOL
		firewall-cmd --zone=trusted --add-source=10.8.0.0/24
		firewall-cmd --permanent --zone=public --add-port=$PORT/$PROTOCOL
		firewall-cmd --permanent --zone=trusted --add-source=10.8.0.0/24
		# Set NAT for the VPN subnet
		firewall-cmd --direct --add-rule ipv4 nat POSTROUTING 0 -s 10.8.0.0/24 ! -d 10.8.0.0/24 -j SNAT --to $IP
		firewall-cmd --permanent --direct --add-rule ipv4 nat POSTROUTING 0 -s 10.8.0.0/24 ! -d 10.8.0.0/24 -j SNAT --to $IP
	else
		# Needed to use rc.local with some systemd distros
		if [[ "$OS" = 'debian' && ! -e $RCLOCAL ]]; then
			echo '#!/bin/sh -e
exit 0' > $RCLOCAL
		fi
		chmod +x $RCLOCAL
		# Set NAT for the VPN subnet
		iptables -t nat -A POSTROUTING -s 10.8.0.0/24 ! -d 10.8.0.0/24 -j SNAT --to $IP
		sed -i "1 a\iptables -t nat -A POSTROUTING -s 10.8.0.0/24 ! -d 10.8.0.0/24 -j SNAT --to $IP" $RCLOCAL
		if iptables -L -n | grep -qE '^(REJECT|DROP)'; then
			# If iptables has at least one REJECT rule, we asume this is needed.
			# Not the best approach but I can't think of other and this shouldn't
			# cause problems.
			iptables -I INPUT -p $PROTOCOL --dport $PORT -j ACCEPT
			iptables -I FORWARD -s 10.8.0.0/24 -j ACCEPT
			iptables -I FORWARD -m state --state RELATED,ESTABLISHED -j ACCEPT
			sed -i "1 a\iptables -I INPUT -p $PROTOCOL --dport $PORT -j ACCEPT" $RCLOCAL
			sed -i "1 a\iptables -I FORWARD -s 10.8.0.0/24 -j ACCEPT" $RCLOCAL
			sed -i "1 a\iptables -I FORWARD -m state --state RELATED,ESTABLISHED -j ACCEPT" $RCLOCAL
		fi
	fi
	# If SELinux is enabled and a custom port was selected, we need this
	if sestatus 2>/dev/null | grep "Current mode" | grep -q "enforcing" && [[ "$PORT" != '1194' ]]; then
		# Install semanage if not already present
		if ! hash semanage 2>/dev/null; then
			yum install policycoreutils-python -y > /dev/null 2>&1
		fi
		semanage port -a -t openvpn_port_t -p $PROTOCOL $PORT
	fi
	# And finally, restart OpenVPN
	if [[ "$OS" = 'debian' ]]; then
		# Little hack to check for systemd
		if pgrep systemd-journal; then
			systemctl restart openvpn@server.service > /dev/null 2>&1
		else
			/etc/init.d/openvpn restart
		fi
	else
		if pgrep systemd-journal; then
			systemctl restart openvpn@server.service > /dev/null 2>&1
			systemctl enable openvpn@server.service > /dev/null 2>&1
		else
			service openvpn restart > /dev/null 2>&1
			chkconfig openvpn on
		fi
	fi
	# If the server is behind a NAT, use the correct IP address
	if [[ "$PUBLICIP" != "" ]]; then
		IP=$PUBLICIP
	fi
	echo -ne " \033[1;31m[ ! ] Generating Client Config"
	# client-common.txt is created so we have a template to add further users later
	echo "client
dev tun
proto $PROTOCOL
sndbuf 0
rcvbuf 0
remote $IP $PORT
resolv-retry infinite
nobind
persist-key
persist-tun
remote-cert-tls server
auth SHA512
$CIPHER
comp-lzo
setenv opt block-outside-dns
key-direction 1
verb 3" > /etc/openvpn/client-common.txt
echo -e "\033[1;32m [OK]"
echo -e "$barra\n\033[1;33m$(source trans -b pt:${id} "Openvpn Configurado Com Sucesso!")"
echo -e "\033[1;33m$(source trans -b pt:${id} "Agora So Criar Um Usuario Para Gerar um Cliente!")\n$barra"
return 0
}

fun_openvpn () {
[[ -e /etc/openvpn/server.conf ]] && {
echo -e "$barra\n\033[1;33m $(source trans -b pt:${id} "OPENVPN ESTA INSTALADO")\n$barra"
echo -e "\033[1;31m [ 1 ] \033[1;33m $(source trans -b pt:${id} "Remover Openvpn")"
echo -e "\033[1;31m [ 2 ] \033[1;33m $(source trans -b pt:${id} "Editar Cliente Openvpn") \033[1;31m(comand nano)\n$barra"
echo -ne "\033[1;33m $(source trans -b pt:${id} "Opcao"): "
read xption
case $xption in 
1)
	echo -e "$barra\n\033[1;33m $(source trans -b pt:${id} "DESINSTALAR OPENVPN")\n$barra"
	if [[ "$OS" = 'debian' ]]; then
	fun_bar "apt-get remove --purge -y openvpn openvpn-blacklist"
	else
	fun_bar "yum remove openvpn -y"
	fi
	tuns=$(cat /etc/modules | grep -v tun) && echo -e "$tuns" > /etc/modules
	rm -f /etc/sysctl.d/30-openvpn-forward.conf
	rm -rf /etc/openvpn && rm -rf /usr/share/doc/openvpn*
	echo -e "$barra\n\033[1;33m $(source trans -b pt:${id} "Procedimento Concluido")\n$barra"
	return 0;;
 2)
   nano /etc/openvpn/client-common.txt
   return 0;;
 esac
 }
[[ -e /etc/squid/squid.conf ]] && instala_ovpn && return 0
[[ -e /etc/squid3/squid.conf ]] && instala_ovpn && return 0
echo -e "$barra\n\033[1;33m $(source trans -b pt:${id} "Squid Nao Encontrado")"
echo -e "\033[1;33m $(source trans -b pt:${id} "Prosseguir Com Instalacao?")\n$barra"
read -p " [S/N]: " -e -i n instnosquid && [[ $instnosquid = @(s|S|y|Y) ]] && instala_ovpn || return 1
}

fun_shadowsocks () {
[[ -e /etc/shadowsocks.json ]] && {
[[ $(ps x|grep ssserver|grep -v grep|awk '{print $1}') != "" ]] && kill -9 $(ps x|grep ssserver|grep -v grep|awk '{print $1}') > /dev/null 2>&1 && ssserver -c /etc/shadowsocks.json -d stop > /dev/null 2>&1
echo -e "${barra}\n\033[1;33m $(source trans -b pt:${id} "SHADOWSOCKS PARADO")\n${barra}${cor[0]}"
rm /etc/shadowsocks.json
return 0
}
       while true; do
       echo -e "${barra}\n\033[1;33m $(source trans -b pt:${id} "Selecione uma Criptografia")\n${barra}${cor[0]}"
       encript=(aes-256-gcm aes-192-gcm aes-128-gcm aes-256-ctr aes-192-ctr aes-128-ctr aes-256-cfb aes-192-cfb aes-128-cfb camellia-128-cfb camellia-192-cfb camellia-256-cfb chacha20-ietf-poly1305 chacha20-ietf chacha20 rc4-md5)
       for((s=0; s<${#encript[@]}; s++)); do
       echo -e " [${s}] - ${encript[${s}]}"
       done
       echo -e "$barra"
       while true; do
       unset cript
       echo -ne "$(source trans -b pt:${id} "Qual Criptografia? Escolha uma Opcao"): "; read cript
       [[ ${encript[$cript]} ]] && break
       echo -e "$(source trans -b pt:${id} "Opcao Invalida")"
       done
       echo -e "$barra"
       encriptacao="${encript[$cript]}"
       [[ ${encriptacao} != "" ]] && break
       echo -e "$(source trans -b pt:${id} "Opcao Invalida")"
      done
#ESCOLHENDO LISTEN
      echo -e "${barra}\n\033[1;33m $(source trans -b pt:${id} "Selecione Uma Porta Para o Shadowsocks Escutar")\n${barra}${cor[0]}"
      while true; do
      unset Lport
      read -p " Listen Port: " Lport
      [[ $(mportas|grep "$Lport") = "" ]] && break
      echo -e " ${Lport}: $(source trans -b pt:${id} "Porta Invalida")"      
      done
#INICIANDO
echo -e "${barra}\n\033[1;33m $(source trans -b pt:${id} "Digite a Senha Shadowsocks")${cor[0]}"
read -p" Pass: " Pass
echo -e "${barra}\n\033[1;33m $(source trans -b pt:${id} "Instalando")\n${barra}${cor[0]}"
fun_bar 'apt-get install python-pip python-m2crypto -y'
fun_bar 'pip install --upgrade pip'
fun_bar 'pip install shadowsocks'
echo -ne '{\n"server":"' > /etc/shadowsocks.json
echo -ne "0.0.0.0" >> /etc/shadowsocks.json
echo -ne '",\n"server_port":' >> /etc/shadowsocks.json
echo -ne "${Lport},\n" >> /etc/shadowsocks.json
echo -ne '"local_port":1080,\n"password":"' >> /etc/shadowsocks.json
echo -ne "${Pass}" >> /etc/shadowsocks.json
echo -ne '",\n"timeout":600,\n"method":"aes-256-cfb"\n}' >> /etc/shadowsocks.json
echo -e "${barra}\n\033[1;31m STARTING\033[0m"
ssserver -c /etc/shadowsocks.json -d start > /dev/null 2>&1
value=$(ps x |grep ssserver|grep -v grep)
[[ $value != "" ]] && value="\033[1;32mSTARTED" || value="\033[1;31mERROR"
echo -e "${barra}\n ${value} ${cor[0]}\n${barra}"
return 0
}

telegran_bot () {
if [[ "$(ps x | grep "ultimatebot" | grep -v "grep")" = "" ]]; then
echo -e "${barra}"
read -p " TELEGRAN BOT TOKEN: " tokenxx
read -p " TELEGRAN BOT LOGUIN: " loguin
read -p " TELEGRAN BOT PASS: " pass
read -p " BOT LINGUAGE [pt/es/en/fr]: " lang
echo -e "${barra}"
echo -e "${loguin}:${pass}" > ./bottokens
screen -dmS screen bash ./ultimatebot "$tokenxx" "$lang" > /dev/null 2>&1
echo -e " LOADING BOT, WAIT"
sleep 10s
echo -e " RUNNING"
echo -e "${barra}"
else
kill -9 $(ps x | grep "ultimatebot" | grep -v "grep" | awk '{print $1}') > /dev/null 2>&1
[[ -e ./bottokens ]] && rm ./bottokens
echo -e "${barra}"
echo -e " BOT STOPED"
echo -e "${barra}"
fi
return 0
}

web_min () {
 [[ -e /etc/webmin/miniserv.conf ]] && {
 echo -e "$barra\n\033[1;32m $(source trans -b pt:${id} "REMOVENDO WEBMIN")\n$barra"
 fun_bar "apt-get remove webmin -y"
 echo -e "$barra\n\033[1;32m $(source trans -b pt:${id} "Webmin Removido")\n$barra"
 [[ -e /etc/webmin/miniserv.conf ]] && rm /etc/webmin/miniserv.conf
 return 0
 }
echo -e " \033[1;36mInstalling Webmin, aguarde:"
fun_bar "wget https://sourceforge.net/projects/webadmin/files/webmin/1.881/webmin_1.881_all.deb"
fun_bar "dpkg --install webmin_1.881_all.deb"
fun_bar "apt-get -y -f install"
rm /root/webmin_1.881_all.deb > /dev/null 2>&1
service webmin restart > /dev/null 2>&1 
echo -e "${barra}\n $(source trans -b pt:${id} "Accede via web usando el enlace: https;//ip_del_vps:10000")\n${barra}"
echo -e "$(source trans -b pt:${id} "Procedimento Concluido")\n${barra}"
return 0
}

iniciarsocks () {
pstop () {
[[ -e /etc/adm-lite/sockson ]] && {
echo -e "${barra}\n $(source trans -b pt:${id} "Parando Socks Python")\n${barra}"
pidproxy=$(ps x | grep "proxypub.py" | grep -v "grep" | awk -F "pts" '{print $1}')
fun_bar "kill -9 $pidproxy"
pidproxy2=$(ps x | grep "proxypriv.py" | grep -v "grep" | awk -F "pts" '{print $1}')
fun_bar "kill -9 $pidproxy2"
pidproxy3=$(ps x | grep "proxydirect.py" | grep -v "grep" | awk -F "pts" '{print $1}')
fun_bar "kill -9 $pidproxy3"
pidproxy4=$(ps x | grep "openproxy.py" | grep -v "grep" | awk -F "pts" '{print $1}')
fun_bar "kill -9 $pidproxy4"
echo -e "${barra}\n $(source trans -b pt:${id} "Socks Parado")\n${barra}"
rm /etc/adm-lite/sockson
[[ -e /etc/adm-lite/sockpub ]] && rm /etc/adm-lite/sockpub
[[ -e /etc/adm-lite/sockpriv ]] && rm /etc/adm-lite/sockpriv
[[ -e /etc/adm-lite/sockdirect ]] && rm /etc/adm-lite/sockdirect
[[ -e /etc/adm-lite/sockopen ]] && rm /etc/adm-lite/sockopen
}
return 0
}
pconfig () {
echo -e "${barra}\n $(source trans -b pt:${id} "Escolha a Porta em que o Socks Vai Escutar")\n${barra}"
while true; do
read -p " Listen Port: " porta_socket
[[ $(mportas|grep $porta_socket) = "" ]] && break || echo -e "$(source trans -b pt:${id} "Porta Invalida")"
done
echo -e "${barra}\n $(source trans -b pt:${id} "Escolha o Texto de Conexao")\n${barra}"
read -p " Text Socket: " texto_soket
}
[[ -e /etc/adm-lite/sockpub ]] && _sockpub="\033[1;32mOn" || _sockpub="\033[1;31mOff"
[[ -e /etc/adm-lite/sockpriv ]] && _sockpriv="\033[1;32mOn" || _sockpriv="\033[1;31mOff"
[[ -e /etc/adm-lite/sockdirect ]] && _sockdirect="\033[1;32mOn" || _sockdirect="\033[1;31mOff"
[[ -e /etc/adm-lite/sockopen ]] && _sockopen="\033[1;32mOn" || _sockopen="\033[1;31mOff"
echo -e "${barra}"
echo -e "\033[1;31m [ 1 ] \033[1;33m$(source trans -b pt:${id} "Socks Python SIMPLE") ${_sockpub}"
echo -e "\033[1;31m [ 2 ] \033[1;33m$(source trans -b pt:${id} "Socks Python SEGURO") ${_sockpriv}"
echo -e "\033[1;31m [ 3 ] \033[1;33m$(source trans -b pt:${id} "Socks Python DIRECTO") ${_sockdirect}"
echo -e "\033[1;31m [ 4 ] \033[1;33m$(source trans -b pt:${id} "Socks Python OPENVPN") ${_sockopen}"
echo -e "\033[1;31m [ 5 ] \033[1;33m$(source trans -b es:${id} "Detener Socks Python")\n${barra}"
while true; do
read -p " Option: " portproxy
    case $portproxy in
    1)
	pconfig
    screen -dmS screen python ./proxypub.py "$porta_socket" "$texto_soket"
	touch /etc/adm-lite/sockpub
	[[ ! -e /etc/adm-lite/sockson ]] && touch /etc/adm-lite/sockson
    break;;
    2)
	pconfig
    screen -dmS screen python3 ./proxypriv.py "$porta_socket" "$texto_soket" "$IP"
	touch /etc/adm-lite/sockpriv
	[[ ! -e /etc/adm-lite/sockson ]] && touch /etc/adm-lite/sockson
    break;;
    3)
	pconfig
    screen -dmS screen python ./proxydirect.py "$porta_socket" "$texto_soket"
	touch /etc/adm-lite/sockdirect
	[[ ! -e /etc/adm-lite/sockson ]] && touch /etc/adm-lite/sockson
    break;;
	4)
	pconfig
    screen -dmS screen python ./openproxy.py "$porta_socket" "$texto_soket"
	touch /etc/adm-lite/sockopen
	[[ ! -e /etc/adm-lite/sockson ]] && touch /etc/adm-lite/sockson
    break;;
	5)
	pstop
    break;;
	*)
	echo -e "${barra}"
	return 0
    esac
done
echo -e "${barra}\n $(source trans -b pt:${id} "Procedimento Concluido")\n${barra}"
return 0
}

gettunel_fun () {
[[ -e /etc/adm-lite/gettun ]] && {
echo -e "${barra}\n $(source trans -b pt:${id} "PARANDO GETTUNEL")\n${barra}"
pid=$(ps x | grep "get.py" | grep -v grep | awk '{print $1}')
if [ "$pid" != "" ]; then
for pids in $(echo $pid); do
fun_bar "kill -9 $pids"
done
fi
rm /etc/adm-lite/gettun
echo -e "${barra}\n $(source trans -b pt:${id} "Gettunel Parado")\n${barra}"
return 0
}
echo -e "${barra}\n $(source trans -b pt:${id} "GETTUNEL PROXY")\n${barra}"
echo -e "${cor[3]} $(source trans -b pt:${id} "Escolha Uma Porta onde Gettunel vai Escutar")"
while true; do
read -p " Listen: " portas
[[ $(mportas|grep $portas) = "" ]] && break || echo -e "$(source trans -b pt:${id} "Porta Invalida")"
done
sed -s "s;CONFIG_LISTENING = '0.0.0.0:8799';CONFIG_LISTENING = '0.0.0.0:$portas';g" ./get > ./get.py
screen -dmS screen python ./get.py
sleep 1s
rm ./get.py
 [[ "$(ps x | grep get.py | grep -v grep | awk '{print $1}')" != "" ]] && {
 echo -e "$(source trans -b pt:${id} "Gettunel Iniciado com Sucesso")"
 echo -e "$(source trans -b pt:${id} "Sua Senha Gettunel e"):"
 echo -e "${cor[3]} Pass:\033[1;32m ADMMANAGER"
 echo -e "$barra"
 touch /etc/adm-lite/gettun
 } || {
echo -e "$barra\n$(source trans -b pt:${id} "Gettunel nao foi iniciado")\n$barra"
 }
}

tcpbypass_fun () {
[[ -e /etc/adm-lite/edbypass ]] && {
echo -e "$barra\n $(source trans -b pt:${id} "Parando Tcp Bypass")\n$barra"
pid=$(ps x | grep "scktcheck" | grep -v grep | awk '{print $1}')
if [ "$pid" != "" ]; then
for pids in $(echo $pid); do
fun_bar "kill -9 $pids"
done
fi
echo -e "$barra\n $(source trans -b pt:${id} "Parado com Sucesso")\n$barra"
rm /etc/adm-lite/edbypass
return 0
}
echo -e "$barra\n $(source trans -b pt:${id} "TCP Bypass ADM")\n$barra"
chmod +x ./overtcp
./overtcp || { 
echo -e "$barra"
return 1
}
touch /etc/adm-lite/edbypass
tput cuu1 && tput dl1
echo -e "$barra\n $(source trans -b pt:${id} "Procedimento Concluido")\n$barra"
return 0
}

ssl_stunel () {
[[ $(mportas|grep stunnel4|head -1) ]] && {
echo -e "$barra"
echo -e "\033[1;33m $(source trans -b pt:${id} "Parando Stunnel")"
echo -e "$barra"
fun_bar "apt-get purge stunnel4 -y"
echo -e "$barra"
echo -e "\033[1;33m $(source trans -b pt:${id} "Parado Com Sucesso!")"
echo -e "$barra"
return 0
}
echo -e "$barra"
echo -e "\033[1;36m $(source trans -b pt:${id} "SSL Stunnel")"
echo -e "$barra"
echo -e "\033[1;33m $(source trans -b pt:${id} "Selecione Uma Porta De Redirecionamento Interna")"
echo -e "\033[1;33m $(source trans -b pt:${id} "Ou seja, uma Porta no Seu Servidor Para o SSL")"
echo -e "$barra"
         while true; do
         echo -ne "\033[1;37m"
         read -p " Local-Port: " portx
         if [[ ! -z $portx ]]; then
             if [[ $(echo $portx|grep [0-9]) ]]; then
                [[ $(mportas|grep $portx|head -1) ]] && break || echo -e "\033[1;31m $(source trans -b pt:${id} "Porta Invalida")"
             fi
         fi
         done
echo -e "$barra"
DPORT="$(mportas|grep $portx|awk '{print $2}'|head -1)"
echo -e "\033[1;33m $(source trans -b pt:${id} "Agora Presizamos Saber Qual Porta o SSL, Vai Escutar")"
echo -e "$barra"
    while true; do
    read -p " Listen-SSL: " SSLPORT
    [[ $(mportas|grep $SSLPORT) ]] || break
    echo -e "\033[1;33m $(source trans -b es:${id} "El puerto seleccionado ya se encuentra en uso")"
    unset SSLPORT
	echo -e "$barra"
	return 0
    done
echo -e "$barra"
echo -e "\033[1;33m $(source trans -b pt:${id} "Instalando SSL")"
echo -e "$barra"
fun_bar "apt-get install stunnel4 -y"
echo -e "cert = /etc/stunnel/stunnel.pem\nclient = no\nsocket = a:SO_REUSEADDR=1\nsocket = l:TCP_NODELAY=1\nsocket = r:TCP_NODELAY=1\n\n[stunnel]\nconnect = 127.0.0.1:${DPORT}\naccept = ${SSLPORT}" > /etc/stunnel/stunnel.conf
openssl genrsa -out key.pem 2048 > /dev/null 2>&1
(echo br; echo br; echo uss; echo speed; echo adm; echo ultimate; echo @admultimate)|openssl req -new -x509 -key key.pem -out cert.pem -days 1095 > /dev/null 2>&1
cat key.pem cert.pem >> /etc/stunnel/stunnel.pem
sed -i 's/ENABLED=0/ENABLED=1/g' /etc/default/stunnel4
service stunnel4 restart > /dev/null 2>&1
echo -e "$barra"
echo -e "\033[1;33m $(source trans -b pt:${id} "INSTALADO COM SUCESSO")"
echo -e "$barra"
return 0
}

painel_upload () {
echo -e "$barra"
echo -e "${cor[2]}$(source trans -b pt:${id} "Deseja Instalar Painel De Upload?")"
echo -e "$barra"
read -p " [ s | n ]: " up_load
echo -e "$barra"
   [[ "$up_load" = @(s|S|y|Y) ]] && bash /etc/adm-lite/insta_painel || {
   echo -e "${cor[2]}$(source trans -b pt:${id} "Instalacao Abortada")"
   echo -e "$barra"
   }
}

antiddos (){
if [ -d '/usr/local/ddos' ]; then
	if [ -e '/usr/local/sbin/ddos' ]; then
		rm -f /usr/local/sbin/ddos
	fi
	if [ -d '/usr/local/ddos' ]; then
		rm -rf /usr/local/ddos
	fi
	if [ -e '/etc/cron.d/ddos.cron' ]; then
		rm -f /etc/cron.d/ddos.cron
	fi
	sleep 4s
	echo -e "\033[1;31m ANTI_DDOS DESINSTALADO CON ÉXITO\033[1;37m"
	echo -e "$barra"
	return 1
else
	mkdir /usr/local/ddos
fi
wget -q -O /usr/local/ddos/ddos.conf https://raw.githubusercontent.com/CarlosPBric/ADM/master/B/ddos.conf -o /dev/null
wget -q -O /usr/local/ddos/LICENSE http://www.inetbase.com/scripts/ddos/LICENSE -o /dev/null
wget -q -O /usr/local/ddos/ignore.ip.list http://www.inetbase.com/scripts/ddos/ignore.ip.list -o /dev/null
wget -q -O /usr/local/ddos/ddos.sh http://www.inetbase.com/scripts/ddos/ddos.sh -o /dev/null
chmod 0755 /usr/local/ddos/ddos.sh
cp -s /usr/local/ddos/ddos.sh /usr/local/sbin/ddos
/usr/local/ddos/ddos.sh --cron > /dev/null 2>&1
sleep 2s
echo -e "\033[1;32m ANTI_DDOS INSTALADO CON ÉXITO.\033[1;37m"
echo -e "$barra"
}

unset squid
unset dropbear
unset openvpn
unset stunel
unset shadow
unset telegran
unset socks
unset gettun
unset tcpbypass
unset webminn
unset ddos
[[ -e /etc/squid/squid.conf ]] && squid="\033[1;32m$(source trans -b pt:${id} "Online")"
[[ -e /etc/squid3/squid.conf ]] && squid="\033[1;32m$(source trans -b pt:${id} "Online")"
[[ -e /etc/default/dropbear ]] && dropbear="\033[1;32m$(source trans -b pt:${id} "Online")"
[[ -e /etc/openvpn/server.conf ]] && openvpn="\033[1;32m$(source trans -b pt:${id} "Configurado")"
[[ $(mportas|grep stunnel4|head -1) ]] && stunel="\033[1;32m$(source trans -b pt:${id} "Online")"
[[ -e /etc/shadowsocks.json ]] && shadow="\033[1;32m$(source trans -b pt:${id} "Online")"
[[ "$(ps x | grep "ultimatebot" | grep -v "grep")" != "" ]] && telegran="\033[1;32m$(source trans -b pt:${id} "Online")"
[[ -e /etc/adm-lite/sockson ]] && socks="\033[1;32m$(source trans -b pt:${id} "Online")"
[[ -e /etc/adm-lite/gettun ]] && gettun="\033[1;32m$(source trans -b pt:${id} "Online")"
[[ -e /etc/adm-lite/edbypass ]] && tcpbypass="\033[1;32m$(source trans -b pt:${id} "Online")"
[[ -e /etc/webmin/miniserv.conf ]] && webminn="\033[1;32m$(source trans -b pt:${id} "Online")"
[[ -e /usr/local/sbin/ddos ]] && ddos="\033[1;32m$(source trans -b pt:${id} "Online")"
echo -e "$barra"
echo -e "\033[1;31m $(source trans -b pt:${id} "MENU INSTALACAO")"
echo -e "$barra"
echo -e "${cor[2]} |1| > ${cor[3]}$(source trans -b pt:${id} "CONFIGURAR") SQUID $squid"
echo -e "${cor[2]} |2| > ${cor[3]}$(source trans -b pt:${id} "CONFIGURAR") DROPBEAR $dropbear"
echo -e "${cor[2]} |3| > ${cor[3]}$(source trans -b pt:${id} "CONFIGURAR") OPENVPN $openvpn"
echo -e "${cor[2]} |4| > ${cor[3]}$(source trans -b pt:${id} "CONFIGURAR") SSL $stunel"
echo -e "${cor[2]} |5| > ${cor[3]}$(source trans -b pt:${id} "CONFIGURAR") SHADOW SOCKS $shadow"
echo -e "${cor[2]} |6| > ${cor[3]}$(source trans -b pt:${id} "CONFIGURAR") PROXY SOCKS $socks"
echo -e "${cor[2]} |7| > ${cor[3]}$(source trans -b pt:${id} "CONFIGURAR") PROXY GETTUNEL $gettun"
echo -e "${cor[2]} |8| > ${cor[3]}$(source trans -b pt:${id} "CONFIGURAR") TCP OVER BYPASS $tcpbypass"
echo -e "${cor[2]} |9| > ${cor[3]}$(source trans -b pt:${id} "CONFIGURAR ") TELEGRAN MANAGER BOT $telegran"
echo -e "${cor[2]} |10| > ${cor[3]}$(source trans -b pt:${id} "CONFIGURAR ") WEBMIN $webminn"
echo -e "${cor[2]} |11| > ${cor[3]}$(source trans -b pt:${id} "CONFIGURAR") Anti-DDOS $ddos"
echo -e "$barra"
echo -ne "\033[1;37m $(source trans -b pt:${id} "Selecione Uma Opcao"): "
read optons
case $optons in
1)
fun_squid
read -p " Enter";;
2)
fun_dropbear
read -p " Enter";;
3)
fun_openvpn
read -p " Enter";;
4)
ssl_stunel
read -p " Enter";;
5)
fun_shadowsocks
read -p " Enter";;
6)
iniciarsocks
read -p " Enter";;
7)
gettunel_fun
read -p " Enter";;
8)
tcpbypass_fun
read -p " Enter";;
9)
telegran_bot
read -p " Enter";;
10)
web_min
read -p " Enter";;
11)
antiddos
read -p " Enter";;
esac

#Reinicia ADM
menu